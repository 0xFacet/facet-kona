//! Contains the [multiplexed_stage] macro.

use thiserror::Error;

/// An error type for the multiplexer stages.
#[derive(Error, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum MultiplexerError {
    /// Thrown when the multiplexer has not yet been activated, but a sub-stage is being accessed.
    #[error("The multiplexer has not been activated.")]
    NotActivated,
}

/// The [multiplexed_stage] macro generates a new stage that swaps its underlying functionality
/// depending on the active hardfork.
///
/// By default, the stage struct generated by this macro:
/// - Implements [OriginAdvancer], [OriginProvider], and [SignalReceiver].
/// - Contains an enum that represents the active stage, in the `stages` key.
/// - Activates stages based on the conditions provided in the `stages` key.
///
/// When a new fork with a stage definition activates, relative to the pipeline origin, the active
/// stage is dissolved and the ownership of the previous stage is transferred to the new stage.
///
/// Stage requirements:
/// - The previous stage must implement [OriginAdvancer], [OriginProvider], [SignalReceiver], and
///   [Debug].
/// - The stages must implement an `into_prev` method that returns the owned previous stage.
///
/// ## Example Usage
/// ```rust,ignore
/// multiplexed_stage!(
///     MyStage<MyPrevStageTrait>,
///     stages: {
///        EcotoneStage => is_ecotone_active,
///     }
///     default_stage: BedrockStage
/// );
/// ```
///
/// To add additional fields to the multiplexer stage, that must be passed to the `new` function of
/// the multiplexer and sub-stages:
/// ```rust,ignore
/// multiplexed_stage!(
///     MyStage<MyPrevStageTrait>,
///     additional_fields: {
///         /// The number of blocks to wait before advancing the origin.
///         block_wait: u64,
///     }
///     stages: {
///        EcotoneStage(block_wait) => is_ecotone_active,
///     }
///     default_stage: BedrockStage
/// );
///
/// // -- snip --
///
/// let cfg = Arc::new(RollupConfig::default());
/// let prev = MyPrevStage::default();
/// MyStage::new(cfg.clone(), prev, 10);
/// ```
///
/// [OriginAdvancer]: crate::pipeline::OriginAdvancer
/// [OriginProvider]: crate::pipeline::OriginProvider
/// [SignalReceiver]: crate::pipeline::SignalReceiver
/// [Debug]: core::fmt::Debug
macro_rules! multiplexed_stage {
    (
        $provider_name:ident<$prev_type:ident$(, $provider_generic:ident: $($provider_generic_bound:ident)*)*>,
        $(
            additional_fields: {
                $(#[doc = $comment:expr])?
                $($field_name:ident: $field_type:ty,)+
            }
        )?
        stages: {
            $($stage_name:ident$(($($input_name:ident$(,)?)+))? => $stage_condition:ident,)*
        }
        default_stage: $last_stage_name:ident$(($($last_input_name:ident$(,)?)+))?
    ) => {
        use $crate::{
            pipeline::{OriginAdvancer, OriginProvider, SignalReceiver, Signal, PipelineError, PipelineResult},
            stages::MultiplexerError
        };
        use async_trait::async_trait;
        use alloc::boxed::Box;

        #[doc = concat!("The active stage of the ", stringify!($provider_name), ".")]
        #[derive(Debug)]
        enum ActiveStage<P$(, $provider_generic: $($provider_generic_bound +)+ core::fmt::Debug)*>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + SignalReceiver + Debug,
        {
            $($stage_name($stage_name<P>,),)*
            $last_stage_name($last_stage_name<P>),
        }

        impl<P$(, $provider_generic: $($provider_generic_bound +)+ core::fmt::Debug)*> ActiveStage<P$(, $provider_generic)*>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + SignalReceiver + Debug,
        {
            /// Dissolves the active stage and returns the previous stage.
            pub(crate) fn into_prev(self) -> P {
                match self {
                    $(ActiveStage::$stage_name(stage) => stage.into_prev(),)*
                    ActiveStage::$last_stage_name(stage) => stage.into_prev(),
                }
            }
        }

        #[doc = concat!("The ", stringify!($provider_name), " stage is responsible for multiplexing sub-stages.")]
        #[derive(Debug)]
        pub struct $provider_name<P$(, $provider_generic: $($provider_generic_bound +)+ core::fmt::Debug)*>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + SignalReceiver + Debug,
        {
            /// The rollup configuration.
            cfg: alloc::sync::Arc<op_alloy_genesis::RollupConfig>,
            /// The previous stage of the derivation pipeline.
            ///
            /// If this is set to [None], the multiplexer has been activated and the active stage
            /// owns the previous stage.
            ///
            /// Must be [None] if `active_stage` is [Some].
            prev: Option<P>,
            /// The active stage of the provider.
            ///
            /// If this is set to [None], the multiplexer has not been activated and the previous
            /// stage is owned by the multiplexer.
            ///
            /// Must be [None] if `prev` is [Some].
            active_stage: Option<ActiveStage<P$(, $provider_generic)*>>,
            $(
                $(#[doc = $comment])?
                $($field_name: $field_type,)+
            )?
        }

        impl<P$(, $provider_generic: $($provider_generic_bound +)+ core::fmt::Debug)*> $provider_name<P$(, $provider_generic)*>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + SignalReceiver + Debug,
        {
            /// Creates a new instance of the provider.
            pub const fn new(cfg: alloc::sync::Arc<op_alloy_genesis::RollupConfig>, prev: P$( $(, $field_name: $field_type)+ )?) -> Self {
                Self {
                    cfg,
                    prev: Some(prev),
                    active_stage: None,
                    $(
                        $($field_name,)+
                    )?
                }
            }

            #[doc = concat!("Returns a mutable ref to the active stage of the ", stringify!($provider_name), ".")]
            const fn active_stage_ref(&self) -> Option<&ActiveStage<P$(, $provider_generic)*>> {
                self.active_stage.as_ref()
            }

            #[doc = concat!("Returns a mutable ref to the active stage of the ", stringify!($provider_name), ".")]
            fn active_stage_mut(&mut self) -> PipelineResult<&mut ActiveStage<P$(, $provider_generic)*>> {
                // If the multiplexer has not been activated, activate the correct stage.
                if let Some(prev) = self.prev.take() {
                    let origin = prev.origin().ok_or(PipelineError::MissingOrigin.crit())?;

                    self.active_stage = Some(
                        $(if self.cfg.$stage_condition(origin.timestamp) {
                            ActiveStage::$stage_name($stage_name::new(self.cfg.clone(), prev$($(, self.$input_name.clone())*)?))
                        } else)* {
                            ActiveStage::$last_stage_name($last_stage_name::new(self.cfg.clone(), prev$($(, self.$last_input_name.clone())*)?))
                        }
                    );
                    return self.active_stage.as_mut().ok_or(PipelineError::from(MultiplexerError::NotActivated).crit());
                } else {
                    // Otherwise, check if the active stage should be changed.
                    let origin = self.origin().ok_or(PipelineError::MissingOrigin.crit())?;
                    let active_stage = self.active_stage.take().ok_or(PipelineError::from(MultiplexerError::NotActivated).crit())?;

                    // If a new stage has activated, transfer ownership of the previous stage to the new stage to
                    // re-link the pipeline at runtime.
                    $(if self.cfg.$stage_condition(origin.timestamp) {
                        // If the correct stage is already active, return it.
                        if matches!(active_stage, ActiveStage::$stage_name(_)) {
                            self.active_stage = Some(active_stage);
                            return self.active_stage.as_mut().ok_or(PipelineError::from(MultiplexerError::NotActivated).crit());
                        }

                        // Otherwise, dissolve the active stage and create a new one, granting ownership of
                        // the previous stage to the new stage.
                        let prev = active_stage.into_prev();
                        self.active_stage = Some(ActiveStage::$stage_name($stage_name::new(self.cfg.clone(), prev$($(, self.$input_name.clone())*)?)));
                    } else)* {
                        // If the correct stage is already active, return it.
                        if matches!(active_stage, ActiveStage::$last_stage_name(_)) {
                            self.active_stage = Some(active_stage);
                            return self.active_stage.as_mut().ok_or(PipelineError::from(MultiplexerError::NotActivated).crit());
                        }

                        self.active_stage = Some(ActiveStage::$last_stage_name($last_stage_name::new(self.cfg.clone(), active_stage.into_prev()$($(, self.$last_input_name.clone())*)?)));
                    }
                }

                self.active_stage.as_mut().ok_or(PipelineError::from(MultiplexerError::NotActivated).crit())
            }
        }

        #[async_trait]
        impl<P$(, $provider_generic: $($provider_generic_bound +)+ core::fmt::Debug)*> OriginAdvancer for $provider_name<P$(, $provider_generic)*>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + SignalReceiver + Send + Debug,
        {
            async fn advance_origin(&mut self) -> PipelineResult<()> {
                match self.active_stage_mut()? {
                    $(ActiveStage::$stage_name(stage) => stage.advance_origin().await,)*
                    ActiveStage::$last_stage_name(stage) => stage.advance_origin().await,
                }
            }
        }

        impl<P$(, $provider_generic: $($provider_generic_bound +)+ core::fmt::Debug)*> OriginProvider for $provider_name<P$(, $provider_generic)*>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + SignalReceiver + Debug,
        {
            fn origin(&self) -> Option<op_alloy_protocol::BlockInfo> {
                match self.active_stage_ref() {
                    Some(stage) => {
                        match stage {
                            $(ActiveStage::$stage_name(stage) => stage.origin(),)*
                            ActiveStage::$last_stage_name(stage) => stage.origin(),
                        }
                    }
                    None => self.prev.as_ref().map(|prev| prev.origin()).flatten(),
                }
            }
        }

        #[async_trait]
        impl<P$(, $provider_generic: $($provider_generic_bound +)+ core::fmt::Debug)*> SignalReceiver for $provider_name<P$(, $provider_generic)*>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + SignalReceiver + Send + Debug,
        {
            async fn signal(
                &mut self,
                signal: Signal,
            ) -> PipelineResult<()> {
                match self.active_stage_mut()? {
                    $(ActiveStage::$stage_name(stage) => stage.signal(signal).await,)*
                    ActiveStage::$last_stage_name(stage) => stage.signal(signal).await,
                }
            }
        }
    }
}

pub(crate) use multiplexed_stage;
