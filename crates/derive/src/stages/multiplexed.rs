//! Contains the [multiplexed_stage] macro.

/// The [multiplexed_stage] macro generates a new stage that swaps its underlying functionality
/// depending on the active hardfork.
///
/// By default, the stage struct generated by this macro:
/// - Implements [OriginAdvancer], [OriginProvider], and [ResettableStage].
/// - Contains an enum that represents the active stage, in the `stages` key.
/// - Activates stages based on the conditions provided in the `stages` key.
///
/// When a new fork with a stage definition activates, relative to the pipeline origin, the active
/// stage is dissolved and the ownership of the previous stage is transferred to the new stage.
///
/// [OriginAdvancer]: crate::pipeline::OriginAdvancer
/// [OriginProvider]: crate::pipeline::OriginProvider
/// [ResettableStage]: crate::pipeline::ResettableStage
macro_rules! multiplexed_stage {
    (
        $provider_name:ident<$prev_type:ident>,
        stages: {
            $($stage_name:ident => $stage_condition:ident,)*
        }
        default_stage: $last_stage_name:ident
    ) => {
        use $crate::pipeline::{OriginAdvancer, OriginProvider, ResettableStage};
        use async_trait::async_trait;
        use alloc::boxed::Box;

        #[doc = concat!("The active stage of the ", stringify!($provider_name), ".")]
        #[derive(Debug)]
        enum ActiveStage<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            $($stage_name($stage_name<P>,),)*
            $last_stage_name($last_stage_name<P>),
        }

        impl<P> ActiveStage<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            /// Dissolves the active stage and returns the previous stage.
            pub(crate) fn into_prev(self) -> P {
                match self {
                    $(ActiveStage::$stage_name(stage) => stage.into_prev(),)*
                    ActiveStage::$last_stage_name(stage) => stage.into_prev(),
                }
            }
        }

        #[doc = concat!("The ", stringify!($provider_name), " stage is responsible for multiplexing sub-stages.")]
        #[derive(Debug)]
        pub struct $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            /// The rollup configuration.
            cfg: alloc::sync::Arc<op_alloy_genesis::RollupConfig>,
            /// The previous stage of the derivation pipeline.
            ///
            /// If this is set to [None], the multiplexer has been activated and the active stage
            /// owns the previous stage.
            ///
            /// Must be [None] if `active_stage` is [Some].
            prev: Option<P>,
            /// The active stage of the provider.
            ///
            /// If this is set to [None], the multiplexer has not been activated and the previous
            /// stage is owned by the multiplexer.
            ///
            /// Must be [None] if `prev` is [Some].
            active_stage: Option<ActiveStage<P>>,
        }

        impl<P> $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            /// Creates a new instance of the provider.
            pub const fn new(cfg: alloc::sync::Arc<op_alloy_genesis::RollupConfig>, prev: P) -> Self {
                Self {
                    cfg,
                    prev: Some(prev),
                    active_stage: None,
                }
            }

            #[doc = concat!("Returns a mutable ref to the active stage of the ", stringify!($provider_name), ".")]
            const fn active_stage_ref(&self) -> Option<&ActiveStage<P>> {
                self.active_stage.as_ref()
            }

            #[doc = concat!("Returns a mutable ref to the active stage of the ", stringify!($provider_name), ".")]
            fn active_stage_mut(&mut self) -> &mut ActiveStage<P> {
                // If the multiplexer has not been activated, activate the correct stage.
                if let Some(prev) = self.prev.take() {
                    let origin = prev.origin().expect("origin must be available");

                    self.active_stage = Some(
                        $(if self.cfg.$stage_condition(origin.timestamp) {
                            ActiveStage::$stage_name($stage_name::new(self.cfg.clone(), prev))
                        } else)* {
                            ActiveStage::$last_stage_name($last_stage_name::new(self.cfg.clone(), prev))
                        }
                    );
                    return self.active_stage.as_mut().expect("Active stage must be available");
                } else {
                    // Otherwise, check if the active stage should be changed.
                    let origin = self.origin().expect("origin must be available");
                    let active_stage = self.active_stage.take().expect("Active stage must be available");

                    // If a new stage has activated, transfer ownership of the previous stage to the new stage to
                    // re-link the pipeline at runtime.
                    $(if self.cfg.$stage_condition(origin.timestamp) {
                        // If the correct stage is already active, return it.
                        if matches!(active_stage, ActiveStage::$stage_name(_)) {
                            self.active_stage = Some(active_stage);
                            return self.active_stage.as_mut().expect("Active stage must be available");
                        }

                        // Otherwise, dissolve the active stage and create a new one, granting ownership of
                        // the previous stage to the new stage.
                        let prev = active_stage.into_prev();
                        self.active_stage = Some(ActiveStage::$stage_name($stage_name::new(self.cfg.clone(), prev)));
                    } else)* {
                        // If the correct stage is already active, return it.
                        if matches!(active_stage, ActiveStage::$last_stage_name(_)) {
                            self.active_stage = Some(active_stage);
                            return self.active_stage.as_mut().expect("Active stage must be available");
                        }

                        self.active_stage = Some(ActiveStage::$last_stage_name($last_stage_name::new(self.cfg.clone(), active_stage.into_prev())));
                    }
                }

                self.active_stage.as_mut().expect("Active stage must be available")
            }
        }

        #[async_trait]
        impl<P> OriginAdvancer for $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Send + Debug,
        {
            async fn advance_origin(&mut self) -> $crate::pipeline::PipelineResult<()> {
                match self.active_stage_mut() {
                    $(ActiveStage::$stage_name(stage) => stage.advance_origin().await,)*
                    ActiveStage::$last_stage_name(stage) => stage.advance_origin().await,
                }
            }
        }

        impl<P> OriginProvider for $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            fn origin(&self) -> Option<op_alloy_protocol::BlockInfo> {
                match self.active_stage_ref() {
                    Some(stage) => {
                        match stage {
                            $(ActiveStage::$stage_name(stage) => stage.origin(),)*
                            ActiveStage::$last_stage_name(stage) => stage.origin(),
                        }
                    }
                    None => self.prev.as_ref().map(|prev| prev.origin()).flatten(),
                }
            }
        }

        #[async_trait]
        impl<P> ResettableStage for $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Send + Debug,
        {
            async fn reset(
                &mut self,
                block_info: op_alloy_protocol::BlockInfo,
                system_config: &op_alloy_genesis::SystemConfig,
            ) -> $crate::pipeline::PipelineResult<()> {
                match self.active_stage_mut() {
                    $(ActiveStage::$stage_name(stage) => stage.reset(block_info, system_config).await,)*
                    ActiveStage::$last_stage_name(stage) => stage.reset(block_info, system_config).await,
                }
            }
        }
    }
}

pub(crate) use multiplexed_stage;
