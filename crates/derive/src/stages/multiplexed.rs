//! Contains the [multiplexed_stage] macro.

/// The [multiplexed_stage] macro generates a new stage that swaps its underlying functionality
/// depending on the active hardfork.
///
/// By default, the stage struct generated by this macro:
/// - Implements [OriginAdvancer], [OriginProvider], and [ResettableStage].
/// - Contains an enum that represents the active stage, in the `stages` key.
/// - Activates stages based on the conditions provided in the `stages` key.
///
/// When a new fork with a stage definition activates, relative to the pipeline origin, the active
/// stage is dissolved and the ownership of the previous stage is transferred to the new stage.
///
/// [OriginAdvancer]: crate::pipeline::OriginAdvancer
/// [OriginProvider]: crate::pipeline::OriginProvider
/// [ResettableStage]: crate::pipeline::ResettableStage
macro_rules! multiplexed_stage {
    (
        $provider_name:ident<$prev_type:ident>,
        stages: {
            $($stage_name:ident => $stage_condition:ident,)*
        }
        default_stage: $last_stage_name:ident
    ) => {
        #[doc = concat!("The active stage of the ", stringify!($provider_name), ".")]
        #[derive(Debug)]
        enum ActiveStage<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            $($stage_name($stage_name<P>,),)*
            $last_stage_name($last_stage_name<P>),
        }

        impl<P> ActiveStage<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            /// Dissolves the active stage and returns the previous stage.
            pub(crate) fn into_prev(self) -> P {
                match self {
                    $(ActiveStage::$stage_name(stage) => stage.into_prev(),)*
                    ActiveStage::$last_stage_name(stage) => stage.into_prev(),
                }
            }
        }

        #[doc = concat!("The ", stringify!($provider_name), " stage is responsible for multiplexing sub-stages.")]
        #[derive(Debug)]
        pub struct $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            #[doc = "The configuration for the stage."]
            cfg: alloc::sync::Arc<op_alloy_genesis::RollupConfig>,
            #[doc = "The previous stage of the derivation pipeline."]
            #[doc = "If this is [None], the provider has been instantiated, and one of the sub-stages owns it."]
            prev: Option<P>,
            #[doc = "The active stage of the provider."]
            active_stage: Option<ActiveStage<P>>,
        }

        impl<P> $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            /// Creates a new instance of the provider.
            pub fn new(cfg: Arc<RollupConfig>, prev: P) -> Self {
                Self {
                    cfg,
                    prev: Some(prev),
                    active_stage: None,
                }
            }

            #[doc = concat!("Returns a mutable ref to the active stage of the ", stringify!($provider_name), ".")]
            fn active_stage_ref(&self) -> Option<&ActiveStage<P>> {
                self.active_stage.as_ref()
            }

            #[doc = concat!("Returns a mutable ref to the active stage of the ", stringify!($provider_name), ".")]
            fn active_stage_mut(&mut self) -> &mut ActiveStage<P> {
                // If the multiplexer has not been activated, activate the correct stage.
                if let Some(prev) = self.prev.take() {
                    let origin = prev.origin().expect("origin must be available");

                    self.active_stage = Some(
                        $(if self.cfg.$stage_condition(origin.timestamp) {
                            ActiveStage::$stage_name($stage_name::new(self.cfg.clone(), prev))
                        } else)* {
                            ActiveStage::$last_stage_name($last_stage_name::new(self.cfg.clone(), prev))
                        }
                    );
                    return self.active_stage.as_mut().expect("Active stage must be available");
                }

                // Otherwise, check if the active stage should be changed.
                let active_stage = self.active_stage.take().expect("Active stage must be available");
                let origin = match active_stage {
                    $(ActiveStage::$stage_name(ref stage) => stage.origin(),)*
                    ActiveStage::$last_stage_name(ref stage) => stage.origin(),
                }.expect("origin must be available");

                // If a new stage has activated, transfer ownership of the previous stage to the new stage to
                // re-link the pipeline at runtime.
                $(if self.cfg.$stage_condition(origin.timestamp) {
                    // If the correct stage is already active, return it.
                    if matches!(active_stage, ActiveStage::$stage_name(_)) {
                        self.active_stage = Some(active_stage);
                        return self.active_stage.as_mut().expect("Active stage must be available");
                    }

                    // Otherwise, dissolve the active stage and create a new one, granting ownership of
                    // the previous stage to the new stage.
                    let prev = active_stage.into_prev();
                    self.active_stage = Some(ActiveStage::$stage_name($stage_name::new(self.cfg.clone(), prev)));
                } else)* {
                    // If the correct stage is already active, return it.
                    if matches!(active_stage, ActiveStage::$last_stage_name(_)) {
                        self.active_stage = Some(active_stage);
                        return self.active_stage.as_mut().expect("Active stage must be available");
                    }

                    self.active_stage = Some(ActiveStage::$last_stage_name($last_stage_name::new(self.cfg.clone(), active_stage.into_prev())));
                }

                self.active_stage.as_mut().expect("Active stage must be available")
            }
        }

        #[async_trait::async_trait]
        impl<P> OriginAdvancer for $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Send + Debug,
        {
            async fn advance_origin(&mut self) -> PipelineResult<()> {
                match self.active_stage_mut() {
                    $(ActiveStage::$stage_name(stage) => stage.advance_origin().await,)*
                    ActiveStage::$last_stage_name(stage) => stage.advance_origin().await,
                }
            }
        }

        impl<P> OriginProvider for $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Debug,
        {
            fn origin(&self) -> Option<BlockInfo> {
                match self.active_stage_ref() {
                    Some(stage) => {
                        match stage {
                            $(ActiveStage::$stage_name(stage) => stage.origin(),)*
                            ActiveStage::$last_stage_name(stage) => stage.origin(),
                        }
                    }
                    None => self.prev.as_ref().map(|prev| prev.origin()).flatten(),
                }
            }
        }

        #[async_trait::async_trait]
        impl<P> ResettableStage for $provider_name<P>
        where
            P: $prev_type + OriginAdvancer + OriginProvider + ResettableStage + Send + Debug,
        {
            async fn reset(
                &mut self,
                block_info: BlockInfo,
                system_config: &SystemConfig,
            ) -> PipelineResult<()> {
                match self.active_stage_mut() {
                    $(ActiveStage::$stage_name(stage) => stage.reset(block_info, system_config).await,)*
                    ActiveStage::$last_stage_name(stage) => stage.reset(block_info, system_config).await,
                }
            }
        }
    }
}

pub(crate) use multiplexed_stage;
